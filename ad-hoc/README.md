# Ad Hoc Doubly-Anonymized Age Verification

If you need to gate access to your online content based on age, but don't want to undertake the cost and liability of implementing verification yourself, you can use SURE.social for free.

SURE.social is a privacy-first service that will not reveal anything to you about a user except their age. We will also not learn anything about you or your content. That's why we say "doubly-anonymized": you won't learn anything about the user (apart from their minimum age), and we won't learn anything about you.

### How it Works

Age verification should be done on your server, not on the client. In our sample, we use an Express web service to implement verification.

The general flow is this:

1. Generate a challenge string and show it to the user.
2. The user copies the challenge string sends it to SURE.social, which generate a claim.
3. The user posts the claim back to you.
4. Decode the claim and check its contents.
5. Retrieve the public key named in the claim from SURE.social's public API.
6. Use the public key to check the signature on the claim.
7. If everything checks out, grant access to the user.

If your site maintains user profiles, then once a user has been verified, you may flag their profile so they won't need to get verified again.

### Generating a Challenge String

A challenge string is just a random nonce appended to the claim you want to check, separated by a dot. Right now we only support two claims: 'over18' and 'over21'.

We suggest you to use random bytes for the challenge string, as we do in the sample, but in practice you can use anything.

### Verifying and Expiring Challenge Strings

We stringly recommend that accept only challenge strings that were generated by your server and that you also expire the challenge strings you create after no more than 15 minutes.

In the sample we do this by generating a JWT, but you can do it in whatever way meets your needs.

### How we Preserve User Privacy

SURE.social never sees the body of the challenge string. Instead, the string is hashed with a randomly generated salt on the user's client before being sent to us. We only sign the hash and return that with the claim. This way, even if the challenge string wasn't random, we would still not learn anything about who created it.

